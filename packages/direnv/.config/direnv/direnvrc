# Direnv Configuration
# Custom direnv functions and settings

# Enable strict environment variable handling
set -euo pipefail

# Layout functions for common project types

# Node.js projects with specific version
layout_nodejs() {
    local version="${1:-lts}"
    
    if ! command -v mise >/dev/null 2>&1; then
        echo "mise not found. Install mise for Node.js version management."
        return 1
    fi
    
    mise use node@"$version"
    PATH_add "$(mise where node@"$version")/bin"
    
    # Add local node_modules/.bin to PATH
    if [[ -d node_modules/.bin ]]; then
        PATH_add node_modules/.bin
    fi
    
    echo "Node.js $version environment activated"
}

# Python projects with virtual environment
layout_python() {
    local python_version="${1:-3.11}"
    local venv_name="${2:-.venv}"
    
    if ! command -v mise >/dev/null 2>&1; then
        echo "mise not found. Install mise for Python version management."
        return 1
    fi
    
    mise use python@"$python_version"
    
    # Create virtual environment if it doesn't exist
    if [[ ! -d "$venv_name" ]]; then
        echo "Creating Python virtual environment: $venv_name"
        python -m venv "$venv_name"
    fi
    
    # Activate virtual environment
    source "$venv_name/bin/activate"
    
    echo "Python $python_version environment activated (venv: $venv_name)"
}

# Go projects with specific version
layout_go() {
    local version="${1:-latest}"
    
    if ! command -v mise >/dev/null 2>&1; then
        echo "mise not found. Install mise for Go version management."
        return 1
    fi
    
    mise use go@"$version"
    
    # Set GOPATH to project-specific directory
    export GOPATH="$PWD/.go"
    PATH_add "$GOPATH/bin"
    
    echo "Go $version environment activated (GOPATH: $GOPATH)"
}

# Rust projects with specific toolchain
layout_rust() {
    local toolchain="${1:-stable}"
    
    if ! command -v rustup >/dev/null 2>&1; then
        echo "rustup not found. Install rustup for Rust toolchain management."
        return 1
    fi
    
    # Set rust toolchain for this project
    if [[ ! -f rust-toolchain.toml ]] && [[ ! -f rust-toolchain ]]; then
        echo "$toolchain" > rust-toolchain
    fi
    
    # Add cargo bin to PATH
    PATH_add "$HOME/.cargo/bin"
    
    echo "Rust $toolchain environment activated"
}

# Docker development environment
layout_docker() {
    local compose_file="${1:-docker-compose.yml}"
    
    if [[ ! -f "$compose_file" ]]; then
        echo "Docker compose file not found: $compose_file"
        return 1
    fi
    
    # Set Docker-related environment variables
    export COMPOSE_FILE="$compose_file"
    export DOCKER_BUILDKIT=1
    export COMPOSE_DOCKER_CLI_BUILD=1
    
    echo "Docker development environment activated (compose: $compose_file)"
}

# AWS profile switching
use_aws() {
    local profile="$1"
    
    if [[ -z "$profile" ]]; then
        echo "Usage: use_aws <profile-name>"
        return 1
    fi
    
    export AWS_PROFILE="$profile"
    export AWS_DEFAULT_PROFILE="$profile"
    
    echo "AWS profile set to: $profile"
}

# Kubernetes context switching
use_kubectl() {
    local context="$1"
    
    if [[ -z "$context" ]]; then
        echo "Usage: use_kubectl <context-name>"
        return 1
    fi
    
    if command -v kubectl >/dev/null 2>&1; then
        kubectl config use-context "$context"
        export KUBECONFIG="$HOME/.kube/config"
        echo "Kubernetes context set to: $context"
    else
        echo "kubectl not found"
        return 1
    fi
}

# Load environment variables from .env file
dotenv() {
    local env_file="${1:-.env}"
    
    if [[ -f "$env_file" ]]; then
        echo "Loading environment from: $env_file"
        # Use direnv's built-in dotenv function
        command dotenv "$env_file"
    else
        echo "Environment file not found: $env_file"
        return 1
    fi
}

# Load secrets from sops-encrypted file
load_secrets() {
    local secrets_file="$1"
    
    if [[ -z "$secrets_file" ]]; then
        echo "Usage: load_secrets <secrets.sops.yaml>"
        return 1
    fi
    
    if [[ ! -f "$secrets_file" ]]; then
        echo "Secrets file not found: $secrets_file"
        return 1
    fi
    
    if ! command -v sops >/dev/null 2>&1; then
        echo "sops not found. Install sops for secrets management."
        return 1
    fi
    
    # Decrypt secrets and export as environment variables
    eval "$(sops -d "$secrets_file" | yq eval '.env_vars // {} | to_entries | .[] | "export " + .key + "=" + (.value | @sh)' -)"
    
    echo "Secrets loaded from: $secrets_file"
}

# Project-specific PATH additions
use_local_bin() {
    PATH_add bin
    PATH_add scripts
    PATH_add .local/bin
    
    echo "Local bin directories added to PATH"
}

# Development database setup (requires Docker)
use_dev_database() {
    local db_type="${1:-postgres}"
    local db_name="${2:-$(basename "$PWD")}"
    
    case "$db_type" in
        postgres|postgresql)
            export DATABASE_URL="postgresql://dev:dev@localhost:5432/$db_name"
            echo "PostgreSQL development database configured: $db_name"
            ;;
        mysql)
            export DATABASE_URL="mysql://dev:dev@localhost:3306/$db_name"
            echo "MySQL development database configured: $db_name"
            ;;
        redis)
            export REDIS_URL="redis://localhost:6379/0"
            echo "Redis development database configured"
            ;;
        *)
            echo "Unsupported database type: $db_type"
            echo "Supported types: postgres, mysql, redis"
            return 1
            ;;
    esac
}

# Enable direnv logging for debugging
# Uncomment the following line to enable debug logging:
# export DIRENV_LOG_FORMAT="$(printf "\033[2mdirenv: %%s\033[0m")"